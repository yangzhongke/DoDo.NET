using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Collections.Immutable;
using System.Text;

namespace DoDo.Net.TextExtraction.SourceGenerators;

[Generator]
public class ExtractorRegistryGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Find all classes that implement ITextExtractor
        var extractorClasses = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (s, _) => IsExtractorClass(s),
                transform: static (ctx, _) => GetExtractorInfo(ctx))
            .Where(static m => m is not null);

        // Generate the registration code
        context.RegisterSourceOutput(extractorClasses.Collect(), GenerateExtractorRegistry);
    }

    private static bool IsExtractorClass(SyntaxNode node)
    {
        if (node is not ClassDeclarationSyntax classDeclaration)
            return false;

        return classDeclaration.BaseList?.Types
            .Any(t => t.Type.ToString().Contains("ITextExtractor")) == true;
    }

    private static ExtractorInfo? GetExtractorInfo(GeneratorSyntaxContext context)
    {
        var classDeclaration = (ClassDeclarationSyntax)context.Node;
        var semanticModel = context.SemanticModel;
        
        var classSymbol = semanticModel.GetDeclaredSymbol(classDeclaration);
        if (classSymbol is null)
            return null;

        // Check if it implements ITextExtractor
        var implementsInterface = classSymbol.AllInterfaces
            .Any(i => i.Name == "ITextExtractor" && 
                     i.ContainingNamespace.ToDisplayString().StartsWith("DoDo.Net.TextExtraction"));

        if (!implementsInterface)
            return null;

        // Skip abstract classes
        if (classSymbol.IsAbstract)
            return null;

        return new ExtractorInfo(
            classSymbol.Name,
            classSymbol.ContainingNamespace.ToDisplayString()
        );
    }

    private static void GenerateExtractorRegistry(SourceProductionContext context, 
        ImmutableArray<ExtractorInfo?> extractors)
    {
        var validExtractors = extractors.Where(e => e is not null).Cast<ExtractorInfo>().ToList();
        
        if (!validExtractors.Any())
            return;

        var source = GenerateRegistrationCode(validExtractors);
        context.AddSource("ExtractorRegistration.g.cs", source);
    }

    private static string GenerateRegistrationCode(List<ExtractorInfo> extractors)
    {
        var sb = new StringBuilder();
        
        sb.AppendLine("// <auto-generated />");
        sb.AppendLine("using DoDo.Net.TextExtraction;");
        
        // Add using statements for extractor namespaces
        var namespaces = extractors.Select(e => e.Namespace).Distinct();
        foreach (var ns in namespaces)
        {
            sb.AppendLine($"using {ns};");
        }
        
        sb.AppendLine();
        sb.AppendLine("namespace DoDo.Net.TextExtraction;");
        sb.AppendLine();
        sb.AppendLine("public static partial class ExtractorRegistration");
        sb.AppendLine("{");
        sb.AppendLine("    public static void RegisterAllExtractors(ExtractorRegistry registry)");
        sb.AppendLine("    {");
        
        foreach (var extractor in extractors)
        {
            sb.AppendLine($"        registry.RegisterExtractor(new {extractor.ClassName}());");
        }
        
        sb.AppendLine("    }");
        sb.AppendLine("}");
        
        return sb.ToString();
    }
}

internal record ExtractorInfo(string ClassName, string Namespace);
